# generated by datamodel-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-11-16T05:13:50+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import BaseModel, Field


class Track(BaseModel):
    """Represents a music track with complete metadata and file information."""

    id: Optional[UUID] = None
    title: Optional[str] = None
    artist: Optional[str] = None
    album: Optional[str] = None
    year: Optional[int] = None
    genre: Optional[str] = None
    mood: Optional[str] = None
    bpm: Optional[int] = None
    key: Optional[str] = None
    duration_seconds: Optional[int] = Field(None, description="Duration in seconds")
    file_path: Optional[str] = None
    file_size_bytes: Optional[int] = Field(None, description="File size in bytes")
    file_format: Optional[str] = Field(None, example="mp3")
    bitrate_bps: Optional[int] = Field(None, description="Bitrate in bits per second")
    sample_rate_hz: Optional[int] = Field(None, description="Sample rate in Hertz (Hz)")
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    last_played: Optional[datetime] = None
    play_count: Optional[int] = None
    metadata_complete: Optional[bool] = None


class TrackCreate(BaseModel):
    """Schema for creating a new track in the library."""

    file_path: str
    title: Optional[str] = None
    artist: Optional[str] = None
    album: Optional[str] = None
    year: Optional[int] = None
    genre: Optional[str] = None
    mood: Optional[str] = None
    bpm: Optional[int] = None
    key: Optional[str] = None


class TrackUpdate(BaseModel):
    """Schema for updating track metadata."""

    title: Optional[str] = None
    artist: Optional[str] = None
    album: Optional[str] = None
    year: Optional[int] = None
    genre: Optional[str] = None
    mood: Optional[str] = None
    bpm: Optional[int] = None
    key: Optional[str] = None


class DetectedMetadata(BaseModel):
    """Metadata detected from audio file analysis."""

    bpm: Optional[int] = None
    key: Optional[str] = None
    duration_seconds: Optional[int] = Field(None, description="Duration in seconds")
    sample_rate_hz: Optional[int] = Field(None, description="Sample rate in Hertz (Hz)")
    bitrate_bps: Optional[int] = Field(None, description="Bitrate in bits per second")


class ConfidenceScores(BaseModel):
    """Confidence scores for detected metadata values."""

    bpm: Optional[float] = None
    key: Optional[float] = None


class MetadataAnalysis(BaseModel):
    """Results of metadata analysis for an audio file."""

    file_path: Optional[str] = None
    detected_metadata: Optional[DetectedMetadata] = None
    confidence_scores: Optional[ConfidenceScores] = None


class Playlist(BaseModel):
    """Represents a playlist with summary information."""

    id: Optional[UUID] = None
    name: Optional[str] = None
    description: Optional[str] = None
    track_count: Optional[int] = None
    total_duration_seconds: Optional[int] = Field(None, description="Total duration in seconds")
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None


class PlaylistDetail(Playlist):
    """Extended playlist model that includes the list of tracks."""

    tracks: Optional[List[Track]] = None


class LibraryOverview(BaseModel):
    """Summary statistics and overview of the entire music library."""

    total_tracks: Optional[int] = None
    total_duration_seconds: Optional[int] = Field(None, description="Total duration in seconds")
    total_size_bytes: Optional[int] = Field(None, description="Total size in bytes")
    total_genres: Optional[int] = None
    average_bpm: Optional[float] = None
    most_common_key: Optional[str] = None
    metadata_completeness: Optional[float] = Field(
        None, description="Percentage of tracks with complete metadata"
    )
    tracks_missing_metadata: Optional[int] = None


class Pagination(BaseModel):
    """Pagination metadata for paginated API responses."""

    page: Optional[int] = None
    size: Optional[int] = None
    total_pages: Optional[int] = None
    total_items: Optional[int] = None
    has_next: Optional[bool] = None
    has_previous: Optional[bool] = None


class GetTracksQueryParams(BaseModel):
    """Query parameters for filtering and paginating tracks."""

    page: int = Field(1, ge=1, description="Page number (1-based)")
    size: int = Field(50, ge=1, le=100, description="Number of items per page")
    search: str = Field("", description="Search query for title, artist, or album")
    genre: str = Field("", description="Filter by genre")
    mood: str = Field("", description="Filter by mood")
    bpm_min: int = Field(0, description="Minimum BPM (inclusive)")
    bpm_max: int = Field(0, description="Maximum BPM (inclusive)")
    key: str = Field("", description="Filter by musical key")
    artist: str = Field("", description="Filter by exact artist name")
    year_min: int = Field(0, description="Minimum year (inclusive)")
    year_max: int = Field(0, description="Maximum year (inclusive)")
    sort_by: str = Field("title", description="Sort column")
    sort_order: str = Field("desc", description="Sort order (asc/desc)")

    class Config:
        """Pydantic config for query parameters."""

        json_schema_extra = {
            "example": {
                "page": 1,
                "size": 50,
                "search": "electronic",
                "genre": "House",
                "bpm_min": 120,
                "bpm_max": 140,
                "sort_by": "title",
                "sort_order": "asc",
            }
        }


class TracksListResponse(BaseModel):
    """Response wrapper for paginated track listings."""

    data: Optional[List[Track]] = None
    pagination: Optional[Pagination] = None


class ScanLibraryRequest(BaseModel):
    """Request schema for scanning music library folders."""

    paths: List[str] = Field(
        ...,
        example=["/Users/username/Music/DJ Collection", "/Users/username/Downloads"],
    )
    include_subfolders: Optional[bool] = True
    watch_for_changes: Optional[bool] = True
    skip_duplicates: Optional[bool] = False


class ScanLibraryResponse(BaseModel):
    """Response schema for library scan operation."""

    scan_id: Optional[UUID] = None
    status: Optional[str] = Field(None, example="scanning")
    message: Optional[str] = Field(None, example="Library scan started")


class HealthResponse(BaseModel):
    """Health check response indicating API status."""

    status: Optional[str] = Field(None, example="healthy")
    version: Optional[str] = Field(None, example="1.0.0")
    timestamp: Optional[datetime] = None


class Status(Enum):
    """Status values for library scan operations."""

    DISCOVERING = "discovering"
    SCANNING = "scanning"
    COMPLETED = "completed"
    FAILED = "failed"


class ScanStatusResponse(BaseModel):
    """Detailed status information for a library scan operation."""

    scan_id: Optional[UUID] = None
    status: Optional[Status] = Field(
        None, description="Current status of the scan operation"
    )
    message: Optional[str] = Field(
        None,
        description=(
            "Current stage message (e.g., 'Discovering audio files...', "
            "'Processing 100 audio file(s)...')"
        ),
        example="Discovering audio files...",
    )
    progress: Optional[float] = Field(
        None, description="Progress percentage (0-100)", example=75.5
    )
    files_scanned: Optional[int] = Field(
        None, description="Total number of files processed", example=1247
    )
    files_added: Optional[int] = Field(
        None, description="Number of files added to the library", example=1200
    )
    files_skipped: Optional[int] = Field(
        None, description="Number of files skipped (duplicates)", example=47
    )
    errors: Optional[List[str]] = Field(
        None, description="List of errors encountered during the scan"
    )
    paths: Optional[List[str]] = Field(
        None,
        description="List of paths being scanned",
        example=["/Users/username/Music", "/Users/username/Documents/Music"],
    )


class BulkDeleteTracksRequest(BaseModel):
    """Request to delete multiple tracks from the library."""

    track_ids: Optional[List[UUID]] = None


class BulkDeleteTracksResponse(BaseModel):
    """Response from bulk track deletion operation."""

    deleted_count: Optional[int] = None


class AnalysisOptions(BaseModel):
    """Options for controlling metadata analysis behavior."""

    detect_bpm: Optional[bool] = True
    detect_key: Optional[bool] = True
    detect_genre: Optional[bool] = False


class AnalyzeMetadataRequest(BaseModel):
    """Request to analyze metadata for a single audio file."""

    file_path: Optional[str] = Field(None, example="/path/to/track.mp3")
    analysis_options: Optional[AnalysisOptions] = None


class ResetMetadataRequest(BaseModel):
    """Request to reset track metadata to original values from file."""

    update_track: Optional[bool] = Field(
        False,
        description="If true, update the track in the database with original metadata",
    )


class ResetMetadataResponse(BaseModel):
    """Response from reset metadata operation."""

    track_id: Optional[UUID] = None
    file_path: Optional[str] = None
    original_metadata: Optional[Dict[str, Any]] = Field(
        None,
        description="Original metadata values read from the audio file",
        example={
            "title": "Song Title",
            "artist": "Artist Name",
            "album": "Album Name",
            "year": 2020,
            "genre": "Electronic",
            "bpm": 128,
            "key": "Am",
        },
    )
    updated: Optional[bool] = Field(
        False, description="Whether the track was updated in the database"
    )


class BatchAnalyzeMetadataRequest(BaseModel):
    """Request to analyze metadata for multiple tracks."""

    track_ids: Optional[List[UUID]] = None


class BatchAnalyzeMetadataResponse(BaseModel):
    """Response from batch metadata analysis operation."""

    job_id: Optional[UUID] = None
    status: Optional[str] = Field(None, example="processing")
    errors: Optional[List[str]] = Field(
        None, description="List of errors encountered during the batch analysis"
    )


class EnhancementOptions(BaseModel):
    """Options for controlling AI metadata enhancement behavior."""

    enhance_genre: Optional[bool] = True
    enhance_mood: Optional[bool] = True
    enhance_bpm: Optional[bool] = True
    enhance_key: Optional[bool] = True


class EnhanceMetadataRequest(BaseModel):
    """Request to enhance track metadata using AI."""

    track_id: UUID
    enhancement_options: Optional[EnhancementOptions] = None


class EnhancedFields(BaseModel):
    """Metadata fields that were enhanced by AI."""

    genre: Optional[str] = None
    mood: Optional[str] = None
    bpm: Optional[int] = None
    key: Optional[str] = None


class ConfidenceScores1(BaseModel):
    """Confidence scores for AI-enhanced metadata values."""

    genre: Optional[float] = None
    mood: Optional[float] = None


class EnhanceMetadataResponse(BaseModel):
    """Response from AI metadata enhancement operation."""

    track_id: Optional[UUID] = None
    enhanced_fields: Optional[EnhancedFields] = None
    confidence_scores: Optional[ConfidenceScores1] = None


class EnhancementOptions1(BaseModel):
    """Options for batch AI metadata enhancement operations."""

    enhance_genre: Optional[bool] = True
    enhance_mood: Optional[bool] = True


class BatchEnhanceMetadataRequest(BaseModel):
    """Request to enhance metadata for multiple tracks using AI."""

    track_ids: Optional[List[UUID]] = None
    enhancement_options: Optional[EnhancementOptions1] = None


class BatchEnhanceMetadataResponse(BaseModel):
    """Response from batch AI metadata enhancement operation."""

    job_id: Optional[UUID] = None
    total_tracks: Optional[int] = None


class Status1(Enum):
    """Status values for enhancement job operations."""

    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"


class EnhancementJobStatus(BaseModel):
    """Status information for an asynchronous enhancement job."""

    job_id: Optional[UUID] = None
    status: Optional[Status1] = None
    progress: Optional[float] = None
    tracks_processed: Optional[int] = None
    tracks_total: Optional[int] = None
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None


class CreatePlaylistRequest(BaseModel):
    """Request to create a new playlist."""

    name: str = Field(..., example="Summer House Mix")
    description: Optional[str] = Field(
        None, example="High energy house tracks for summer sets"
    )


class UpdatePlaylistRequest(BaseModel):
    """Request to update playlist metadata."""

    name: Optional[str] = None
    description: Optional[str] = None


class AddTracksToPlaylistRequest(BaseModel):
    """Request to add tracks to a playlist."""

    track_ids: Optional[List[UUID]] = None


class RemoveTracksFromPlaylistRequest(BaseModel):
    """Request to remove tracks from a playlist."""

    track_ids: Optional[List[UUID]] = None


class Format(Enum):
    """Supported playlist export formats."""

    M3U = "m3u"
    PLS = "pls"
    XSPF = "xspf"
    JSON = "json"


class ExportPlaylistRequest(BaseModel):
    """Request to export a playlist to a file."""

    format: Optional[Format] = Format.M3U
    output_path: Optional[str] = None


class ExportPlaylistResponse(BaseModel):
    """Response from playlist export operation."""

    file_path: Optional[str] = None
    format: Optional[str] = None


class DistributionItem(BaseModel):
    """Single item in a BPM distribution analysis."""

    range: Optional[str] = Field(None, example="120-140")
    count: Optional[int] = None
    percentage: Optional[float] = None


class BPMDistributionResponse(BaseModel):
    """BPM distribution analysis results."""

    distribution: Optional[List[DistributionItem]] = None


class DistributionItem1(BaseModel):
    """Single item in a key distribution analysis."""

    key: Optional[str] = Field(None, example="Am")
    count: Optional[int] = None
    percentage: Optional[float] = None


class KeyDistributionResponse(BaseModel):
    """Musical key distribution analysis results."""

    distribution: Optional[List[DistributionItem1]] = None


class DistributionItem2(BaseModel):
    """Single item in a genre distribution analysis."""

    genre: Optional[str] = None
    count: Optional[int] = None
    percentage: Optional[float] = None


class GenreDistributionResponse(BaseModel):
    """Genre distribution analysis results."""

    distribution: Optional[List[DistributionItem2]] = None


class DistributionItem3(BaseModel):
    """Single item in a mood distribution analysis."""

    mood: Optional[str] = None
    count: Optional[int] = None
    percentage: Optional[float] = None


class MoodDistributionResponse(BaseModel):
    """Mood distribution analysis results."""

    distribution: Optional[List[DistributionItem3]] = None


class RefdataType(Enum):
    """Available reference data types."""

    TRACKFILTERS = "trackfilters"


class RefdataItem(BaseModel):
    """A single key-value pair in reference data."""

    key: str = Field(..., description="The filter category name (e.g., 'genre', 'mood')")
    value: List[str] = Field(..., description="List of filter options for this category")


class RefdataResponse(BaseModel):
    """Reference data response as an array of key-value pairs."""

    data: List[RefdataItem] = Field(..., description="Array of reference data categories with their options")


class CreateRefdataRequest(BaseModel):
    """Request schema for creating or updating reference data."""

    key: str = Field(..., description="The filter category name (e.g., 'genre', 'mood')")
    value: List[str] = Field(
        ...,
        description="List of values to store for this key",
    )


class CreateRefdataResponse(BaseModel):
    """Response schema for creating reference data."""

    type: str = Field(..., description="The reference data type")
    key: str = Field(..., description="The filter category name")
    created_count: int = Field(..., description="Number of new entries created")
    updated_count: int = Field(..., description="Number of existing entries updated")


class DeleteRefdataResponse(BaseModel):
    """Response schema for deleting reference data."""

    type: str = Field(..., description="The reference data type")
    key: str = Field(..., description="The filter category name")
    deleted_count: int = Field(..., description="Number of entries deleted")
